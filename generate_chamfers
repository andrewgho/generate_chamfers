#!/usr/bin/env ruby
# generate_chamfers - generate chamfers to smoothly join rectangle to polygon
# Andrew Ho (andrew@zeuscat.com)

# Main loop, run at end
def main(argv = [])

  # Parameters and keyway path taken from GMS MX keyway project
  width = 2.34
  height = 8.56
  epsilon = 0.1

  path = [
    [0.00, 0.00],
    [0.00, 0.75], [0.65, 0.75],
    [1.41, 2.48], [0.00, 2.48],
    [0.00, 5.13],
    [1.23, 5.65],
    [0.11, 6.97],
    [0.75, 8.56], [1.67, 8.56],
    [1.11, 7.00],
    [2.23, 5.70],
    [2.23, 5.38],
    [0.81, 4.83],
    [0.81, 3.29], [2.15, 3.29],
    [2.34, 2.86],
    [1.45, 0.75], [2.34, 0.75],
    [2.34, 0.00]
  ]

  # This is the target polygon from the path
  polygon = Polygon.new(path)

  # Find closest point to each corner, so we know which wall to ramp towards
  idx_bottom_left  = polygon.closest_point_index(0, 0)
  idx_top_left     = polygon.closest_point_index(0, height)
  idx_top_right    = polygon.closest_point_index(width, height)
  idx_bottom_right = polygon.closest_point_index(width, 0)

  puts (<<-"end").gsub(/^    /, ''), ''
    // OpenSCAD chamfers() module autogenerated by #{File.basename($0)}
    // Andrew Ho (andrew@zeuscat.com)

    module chamfers(distance) {
      // Epsilon value for creating tiny solid segments from 2D shapes
      e = #{epsilon};

      // Draw polygons at start (rectangle) and end (polygon) area
      module start_polygon(points) {
        translate([0, 0, -e]) linear_extrude(e) polygon(points);
      }
      module end_polygon(points) {
        translate([0, 0, distance - e]) linear_extrude(e) polygon(points);
      }

      // Draw starting cube and ending total polygon
      translate([0, 0, -e]) cube([#{width}, #{height}, e]);
      end_polygon(#{polygon.to_openscad});
  end

  polygon.lines.each_with_index do |line, i|
    # Create epsilon-length vector, starting from midpoint, pointing inwards
    perpendicular = line.
      scale_to_length(epsilon).
      translate_to_point(line.midpoint).
      rotate(-Math::PI / 2)

    # Create tiny epsilon-height triangle for end polygon
    end_vertex = perpendicular.p2
    end_polygon = Polygon.new(line, end_vertex)

    # Create start polygon with edge points at whichever wall we ramp towards
    start_polygon = Polygon.new(line.p2, end_vertex, line.p1)
    if i >= idx_bottom_left  && i < idx_top_left
      start_polygon << Point.new(0, line.y1)
      start_polygon << Point.new(0, line.y2)
    elsif i >= idx_top_left && i < idx_top_right
      start_polygon << Point.new(line.x1, height)
      start_polygon << Point.new(line.x2, height)
    elsif i >= idx_top_right && i < idx_bottom_right
      start_polygon << Point.new(width, line.y1)
      start_polygon << Point.new(width, line.y2)
    elsif i >= idx_bottom_right && i < idx_bottom_left
      start_polygon << Point.new(line.x1, 0)
      start_polygon << Point.new(line.x2, 0)
    end

    # Output hull of start and end polygons
    puts (<<-"end").gsub(/^    /, '')
      hull() {
        start_polygon(#{start_polygon.to_openscad});
        end_polygon(#{end_polygon.to_openscad});
      }
    end
  end

  # Finish off module definition from above
  puts '}'

  0
end

# Represent 2D polygon
class Polygon
  attr_accessor :points

  # Intialize Point from Points, Lines, or arrays thereof
  def initialize(*points_or_lines)
    @points = []
    points_or_lines.each { |pol| self << pol }
  end

  # Add a Point, a Line, or arrays thereof
  def <<(*things)
    if things.size == 1
      thing = things.first
      if thing.is_a?(Point)
        @points << thing
      elsif thing.is_a?(Line)
        @points << thing.p1
        @points << thing.p2
      elsif thing.is_a?(Array)
        if thing.size == 2 && thing.all? { |e| e.numeric? }
          @points << Point.new(thing)
        else
          thing.each { |e| self << e }
        end
      else
        raise 'arguments must be Points or Lines'
      end
    else
      self << things
    end
  end

  # Return the number of edges/corners that make up this polygon
  def n
    points.size
  end

  # A polygon is only valid if it has three or more sides
  def valid?
    n >= 3
  end

  # Return Lines that make up this Polygon
  def lines
    raise 'invalid polygon' unless valid?
    0.upto(points.size - 1).collect do |i|
      Line.new(points[i % n], points[(i + 1) % n])
    end
  end

  # Return the Point closest to the other point specified
  def closest_point_index(*other)
    other = Point.new(*other)
    0.upto(n - 1).sort_by { |i| Line.new(points[i], other).length }.first
  end

  # Show (x1, y1) -> (x2, y2) -> (x3, y3)
  def to_s
    if points.empty?
      'empty'
    elsif !valid?
      'invalid ' + points.collect { |p| p.to_s }.join(" \u{2192} ")
    else
      points.collect { |p| p.to_s }.join(" \u{2192} ")
    end
  end

  # Show [[x1, y1], [x2, y2], [x3, y3]]
  def to_openscad
    "[#{points.collect { |p| p.to_openscad }.join(', ')}]"
  end
end

# Represent 2D directional line (vector defined by start and end points)
class Line
  attr_accessor :p1, :p2

  # Initialize Line from any two things that could be passed to Point.new()
  def initialize(p1, p2)
    @p1 = Point.new(p1)
    @p2 = Point.new(p2)
  end

  # Getters and setters for individual point components
  def x1; p1.x; end; def x1=(x); p1.x = x; end
  def y1; p1.y; end; def y1=(y); p1.y = y; end
  def x2; p2.x; end; def x2=(x); p2.x = x; end
  def y2; p2.y; end; def y2=(y); p2.y = y; end

  # Return numeric length of line
  def length
    Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2))
  end

  # Return new line scaled by factor
  def scale(factor)
    x = x2 - x1
    y = y2 - y1
    Line.new(p1, Point.new(x1 + (x * factor), y1 + (y * factor)))
  end

  # Scale line to particular length
  def scale_to_length(new_length)
    self.scale(new_length / length)
  end

  # Return new line translated so p1 is at particular location
  def translate_to_point(*location)
    p = Point.new(*location)
    Line.new(p, Point.new(p.x + (x2 - x1), p.y + (y2 - y1)))
  end

  # Return new line rotated counter-clockwise by angle in radians
  def rotate(angle)
    x = x2 - x1
    y = y2 - y1
    cos_angle = Math.cos(angle)
    sin_angle = Math.sin(angle)
    new_x = (x * cos_angle) - (y * sin_angle)
    new_y = (x * sin_angle) - (y * cos_angle)
    Line.new(p1, Point.new(x1 + new_x, y1 + new_y))
  end

  # Return Point which is midpoint of this line
  def midpoint
    Point.new((x1 + x2) / 2, (y1 + y2) / 2)
  end

  # Show (x1, y1) -> (x2, y2)
  def to_s
    "#{p1} \u{2192} #{p2}"
  end
end

# Represent point in 2D plane
class Point
  attr_accessor :x, :y

  # Intialize Point from Point, array of two numbers, or two numbers
  def initialize(*args)
    if args.size == 1
      arg = args.first
      if arg.is_a?(Point)
        @x, @y = arg.x, arg.y
      elsif arg.is_a?(Array) && arg.size == 2
        @x, @y = arg[0, 2]
      end
    elsif args.size == 2
      @x, @y = args[0, 2]
    end
    unless @x && @y && @x.numeric? && @y.numeric?
      raise 'arguments must be two numbers, or an array of two numbers'
    end
  end

  def +(other); Point.new(x + other.x, y + other.y); end
  def -(other); Point.new(x - other.x, y - other.y); end

  # Return new point translated by (x, y) offset
  def translate(*offset)
    p = Point.new(*offset)
    self + p
  end

  # Show (x, y)
  def to_s
    "(#{x.to_pretty_num}, #{y.to_pretty_num})"
  end

  # Show [x, y]
  def to_openscad
    "[#{x.to_pretty_num}, #{y.to_pretty_num}]"
  end
end

# Pretty-print Floats where last two digits of precision are ignorable
class Numeric
  def to_pretty_num
    self
  end
end
class Float
  def to_pretty_num
    if self.round(Float::DIG - 2) == self.round(Float::DIG - 3)
      num = self.round(Float::DIG - 2)
      num == 0.0 ? 0 : num  # Also, return integer 0 instead of 0.0
    else
      self
    end
  end
end

# Allow Objects to be queried as to whether they are numeric?
class Object
  def numeric?
    self.is_a?(Numeric)
  end
end

# Run main loop and exit
exit main(ARGV)
